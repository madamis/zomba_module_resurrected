 # -*- coding: utf-8 -*-
"""
/***************************************************************************
 Zomba
                                 A QGIS plugin
 zombaland management system
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-05-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by chanco
        email                : madamiss@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import psycopg2 as psycopg2
from PyQt5 import QtSql, QtGui
from fpdf import FPDF
from qgis.core import *
from qgis.utils import iface
from qgis.gui import *
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QVariant
from PyQt5.QtGui import QIcon, QColor
from PyQt5.QtWidgets import QAction, QMessageBox, QTableView, QWidget, QListWidgetItem, QVBoxLayout, QTextEdit
from PyQt5.uic import loadUi
#import geopandas
from .developer import Developer
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .zomba_module_dialog import ZombaDialog, EditPane, ViewDeletePane, CustomeUI, ReceiptPane
import os.path

class Zomba:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Zomba_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Zomba_CLMS')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Zomba', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/zomba_module/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Files'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Zomba_LMS'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ZombaDialog()
            self.customeUi = CustomeUI()
            self.viewDeletePane = ViewDeletePane()
            self.editPane = EditPane()
            self.swidget = self.dlg.stackedWidget
            self.swidget.setCurrentIndex(2)
            self.receiptPane = ReceiptPane()

        self.dlg.mainLeftList.itemSelectionChanged.connect(self.selectionChanged)
        self.dlg.filterList.textChanged.connect(self.filterListOnType)
        self.dlg.login.clicked.connect(self.handle_login)
        #        self.selection()
        self.dlg.add_btn_2.clicked.connect(self.add_btn_handler)
        self.dlg.save.clicked.connect(self.save_btn_handler)
        self.receiptPane.receipt_ok.clicked.connect(self.handle_receipt_ok)
        self.editPane.editclose.clicked.connect(self.handle_editclose)
        self.dlg.customers_list.setCurrentIndex(-1)
        self.populateLeftList()
        self.available_plot_numbers()
        self.available_customers()
        self.developers()
        self.dlg.actionLogout.triggered.connect(self.handle_logout)
        self.dlg.actionGeneral_Report.triggered.connect(self.handle_general_Report)
        self.dlg.actionHelp.triggered.connect(self.handle_action_help)
        self.rendermap()
        print('editing this')
        self.swidget.setCurrentIndex(1)
        print(self.swidget.currentIndex())
        if self.swidget.currentIndex()==1:
            self.disablemenus()
        self.dlg.show()

    def disablemenus(self):
        self.dlg.actionLogout.setDisabled(True)
        self.dlg.actionGeneral_Report.setDisabled(True)
        self.dlg.actionHelp.setDisabled(True)

    def enablemenus(self):
        self.dlg.actionLogout.setDisabled(False)
        self.dlg.actionGeneral_Report.setDisabled(False)
        self.dlg.actionHelp.setDisabled(False)

    def handle_receipt_ok(self):
        self.receiptPane.close()

    def handle_logout(self):
        print("am loging out")
        self.swidget.setCurrentIndex(1)

    def handle_general_Report(self):
        self.swidget.setCurrentIndex(3)

    def handle_action_help(self):
        self.swidget.setCurrentIndex(2)

    def handle_login(self):
        connection = self.connection()
        cursor = connection.cursor()
        crudentialquery = "SELECT username, password FROM finale_users"
        cursor.execute(crudentialquery)

        USERNAME = self.dlg.logusername.text()
        PASSWORD = self.dlg.logpassword.text()

        get_crudentials = ("select * from finale_users where username = '" + USERNAME + "' AND PASSWORD = '" + PASSWORD + "'; ")
        cursor.execute(get_crudentials)

        records = cursor.fetchall()
        if len(records) > 0:
            self.swidget.setCurrentIndex(0)
            self.enablemenus()
        else:
            self.showdialog("entered wrong values")

    def handle_cancel_on_delete(self):
        self.viewDeletePane.close()

    def handle_editclose(self):
        self.editPane.close()

    def handle_close(self):
        # self.report_plot_numbers()
        # self.report_customers()
        self.dlg.hide()

    def selectionChanged(self):
        txt = self.getSelectedFeature(self.dlg.mainLeftList)
        filter = ''
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """select plot_number from finale_plot where plot_name = '"""+txt+"""';"""
            cursor.execute(query)
            pn = cursor.fetchone()
            filter = str(pn[0])
            details_query = """
                select FP.plot_number, ST_Area(the_geom)/1000000 area, 
                ST_Perimeter(the_geom) perimeter, ST_Distance(central_geom, the_geom), 
                FL.village_name, FL.ta_name from (select t.plot_number, t.geom the_geom, s.geom central_geom, t.location_id 
                from finale_plot s, finale_plot t where s.plot_number = '30340' and t.plot_number = '"""+filter+"""') FP 
                join finale_location FL on FP.location_id = FL.location_id where FP.plot_number = '"""+filter+"""';"""
            #select plot_number, area, perimeter, occupied, longtude, latitude, distance """
            details_cursor = connection.cursor()
            details_cursor.execute(details_query)
            row = details_cursor.fetchone()
            self.populate_details(row)

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed from on selection change', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()
        self.selected_layer(filter)

    def getSelectedFeature(self,list):
        row = list.currentRow()
        item = list.item(row)
        self.dlg.selectedFeature.setText(item.text())
        return item.text()

    def populateLeftList(self):
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """select plot_name from finale_plot;"""
            cursor.execute(query)
            self.dlg.mainLeftList.addItems(str(x[0]) for x in cursor)

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed to connect from populate details', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def populate_details(self, row):
        #row = [plot number, area, perimeter, occupied,
        # longtude, latitude, distance
        # coordinates,plot name, area, perimeter, latitude, longtude distance from city council
        self.dlg.reference_no.setText(str(row[0]))
        self.dlg.area.setText(self.format_area(row[1]))
        self.dlg.perimeter.setText(self.format_area(row[2]))
        #self.dlg.occupied.setText(row[3])
        self.dlg.longtude.setText(str(row[4]))
        self.dlg.latitude.setText(str(row[5]))
        self.dlg.distance.setText(self.format_area(row[3]))

    def addQuote(self, name):
        if name.find("'")>=0:
            return name[:name.find("'")]+"'"+name[name.find("'"):]
        return name

    def filterListOnType(self):
        filter_text =  self.dlg.filterList.text().lower()
        #row = self.dlg.mainLeftList.currentRow()
        for it in range(self.dlg.mainLeftList.count()):
            item = self.dlg.mainLeftList.item(it)
            if filter_text in item.text().lower():
                self.dlg.mainLeftList.setRowHidden(it, False)
            else:
                self.dlg.mainLeftList.setRowHidden(it, True)

    def add_btn_handler(self):
        firstname = self.dlg.firstname.text()
        lastname = self.dlg.lastname.text()
        phone = self.dlg.phone.text()
        address = self.dlg.address.toPlainText()

        if len(firstname) == 0 or len(lastname)==0 or len(phone)==0 or len(address)==0:
            self.showdialog("PLEASE CHECK YOUR INPUT DATA\nYOU HAVE AN EMPTY FILD")
        else:
            try:
                connection = self.connection()
                cursor = connection.cursor()
                insert_developer = """insert into finale_owner (firstname, lastname) 
                            values ('""" + firstname + """', '""" + lastname + """') returning owner_id;"""
                cursor.execute(insert_developer)
                owner_id = cursor.fetchone()[0]
                connection.commit()
                insert_contacts = """insert into finale_contact(owner_id, phone, address)
                        values('""" + str(owner_id) + """', '""" + str(phone) + """', '""" + address + """');"""
                cursor.execute(insert_contacts)
                connection.commit()
                self.showdialog("Developer added sucessifully")
                firstname = self.dlg.firstname.setText('')
                lastname = self.dlg.lastname.setText('')
                phone = self.dlg.phone.setText('')
                address = self.dlg.address.setText('')
            except(Exception, psycopg2.Error) as error:
                if (connection):
                    print("failed at add btn handler", error)
            finally:
                '''closing database connection'''
                if (connection):
                         cursor.close()
                         connection.close()
            self.available_customers()

    def save_btn_handler(self):
        plot = self.dlg.plot_combo.currentText()
        customer = self.dlg.customers_list.currentText()
        charged = self.dlg.charged_amount.text()
        payment = self.dlg.payed_amount.text()
        customer = customer[:-7]

        if len(plot)==0 or len(customer)==0 or len(charged)==0 or len(payment)==0:
            self.showdialog("PLEASE CHECK YOUR INPUTS")
        else:
            try:
                connection = self.connection()
                cursor = connection.cursor()
                id = """
                    select id from (
                        select owner_id id, concat(firstname,' ',lastname) as co from finale_owner) fila
                        where co = '"""+customer+"""'
                """
                cursor.execute(id)
                ow_id = cursor.fetchone()[0]
                cursor.execute("""select plot_number from finale_plot where plot_name ='"""+plot+"""'""")
                pl_id = cursor.fetchone()[0]
                insert_developer = """insert into finale_owns (owner_id, plot_id,amount_charged)
                                    values ('"""+str(ow_id)+"""','"""+ str(pl_id)+"""', '"""+str(charged)+"""') returning id;"""
                cursor.execute(insert_developer)
                owns = cursor.fetchone()[0]
                connection.commit()
                insert_payment = """insert into finale_payment(owns, amount)
                                values('"""+str(owns)+"""', '"""+str(payment)+"""') returning id"""
                cursor.execute(insert_payment)
                pid = cursor.fetchone()
                connection.commit()
                self.receiptPane.ref_number.setText(self.myFunc(pid[0]))
                self.receiptPane.rec_amount.setText(charged)
                self.receiptPane.rec_date.setText('_')
                self.receiptPane.rec_paid.setText(payment)
                self.dlg.reporttext.setText('Sucessifully assigned '+customer+' to '+plot)
                self.receiptPane.print_btn.clicked.connect(self.handleprint)
                self.receiptPane.show()
                self.dlg.plot_combo.setCurrentIndex(-1)
                self.dlg.customers_list.setCurrentIndex(-1)
                self.dlg.charged_amount.setText('')
                self.dlg.payed_amount.setText('')
            except(Exception, psycopg2.Error) as error:
                if (connection):
                    print('failed to connect at save btn', error)
            finally:
                '''closing database connection'''
                if (connection):
                    cursor.close()
                    connection.close()
            self.available_plot_numbers()
            self.available_customers()
            self.dlg.developerslistwidget.clear()

            self.developers()

    def handleprint(self):
        print("handling print")
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        pdf.cell(200, 10, txt="Welcome to Python!", ln=1, align="C")
        pdf.output("simple_demo.pdf")

    def myFunc(self, txt):
        text = '00000000'
        txt = str(txt)
        si = len(txt)
        text = text + txt
        text = text[si:]
        return text

    def showdialog(self,feedback):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)

        msg.setText(feedback)
        msg.setInformativeText(" ")
        msg.setWindowTitle("Add dev")
        msg.setDetailedText("")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        #msg.buttonClicked.connect(self.msgbtn)

        retval = msg.exec_()

    def msgbtn(i):
        pass

    def round_number_to2dp(self, number):
        rigth = number[:number.find('.')]
        left = number[number.find('.'):number.find('.')+2]
        return rigth + left

    def format_area(self, area):
        strnum = str(area)
        left = strnum[:strnum.find('.')]
        right = strnum[strnum.find('.'):]

        keep = count = len(left)
        fin = ''
        for i in left:
            if count % 3 == 0 and count != 0 and count != keep:
                fin += ', '
            fin += i
            count -= 1
        right += ' Meters'
        fin += right
        return self.round_number_to2dp(fin)

    def selection(self):
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """select fname, lname, plot_name, st_area(geom) area from developer Dv, plot Pl where Dv.plot_no = Pl.plot_no;"""
            cursor.execute(query)
        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('faileed to connect from selextion', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def connection(self):
        connection = psycopg2.connect(user='postgres', password='12345678', host='localhost', port='5432',
                                      database='zomba_malawi')
        return connection

    def available_plot_numbers(self):
        self.dlg.plot_combo.clear()
        connection = self.connection()
        cursor = connection.cursor()
        query = """select plot_name from finale_plot where plot_name not in (
                    select plot_name from finale_plot FP join finale_owns FO on FP.plot_number = FO.plot_id);
                """
        cursor.execute(query)
        for i in cursor:
            self.dlg.plot_combo.addItem(i[0])
        self.dlg.plot_combo.setCurrentIndex(-1)

    def available_customers(self):
        try:
            self.dlg.customers_list.clear()
            connection = self.connection()
            cursor = connection.cursor()
            query = """select number_of_plots, owner_id, firstname,lastname from(
                                    select count(id) number_of_plots, owner_id from(
                                        select id, owner_id from finale_owns union select 0 padding, 
                                        owner_id from finale_owner) as comb group by owner_id) owners 
                                    natural join 
                                finale_owner;
                            """
            cursor.execute(query)
            for i in cursor:
                self.dlg.customers_list.addItem(i[2]+" "+i[3]+"    ["+str(i[0]-1)+"]")
            self.dlg.customers_list.setCurrentIndex(-1)

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed to connect from availabe customers', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def developers(self):
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """
                select 
	            P.owner_id, firstname, lastname, phone, address, plot_id, amount_charged, 
                plot_name, ST_Area(geom), O.created_at, location_id
	            from finale_owns O join finale_owner P on O.owner_id = P.owner_id 
	            join finale_contact L on P.owner_id = L.owner_id 
	            join finale_plot FP on O.plot_id = FP.plot_number;
	            """
            cursor.execute(query)
            for c in cursor:
                self.viewDevelopersDetails(c)

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('faileed to connect  from developers', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def viewDevelopersDetails(self,rowFromQuery):
        self.customeUi = CustomeUI()
        self.customeUi.developer.setText(rowFromQuery[1] + " " + rowFromQuery[2])
        self.customeUi.landdetails.setText(rowFromQuery[7] + " that occupy " + str(rowFromQuery[8]) + " km2")
        self.customeUi.date_offered.setText("Granted on " + str(rowFromQuery[9]))
        self.customeUi.phonenumber.setText(rowFromQuery[3])
        self.customeUi.chikanda.setText(rowFromQuery[4])
        self.customeUi.viewDelete.clicked.connect(lambda x : self.handle_del_on_list([rowFromQuery[0], rowFromQuery[5]]))
        self.customeUi.edit_list_btn.clicked.connect(lambda x : self.handle_edit_on_list([rowFromQuery[0], rowFromQuery[5]]))
        self.wrapCustomeUiLabels()
        myQListWidgetItem = QListWidgetItem(self.dlg.developerslistwidget)
        myQListWidgetItem.setSizeHint(self.customeUi.sizeHint())
        self.dlg.developerslistwidget.addItem(myQListWidgetItem)
        self.dlg.developerslistwidget.setItemWidget(myQListWidgetItem, self.customeUi)

    def wrapCustomeUiLabels(self):
        self.customeUi.landdetails.setWordWrap(True)

    def handle_del_on_list(self, lst):
        owner_id = str(lst[0])
        plot_id = str(lst[1])
        self.view_delete_pane_details(owner_id, plot_id)
        self.viewDeletePane.show()
        self.dlg.developerslistwidget.clear()
        self.developers()
        self.available_customers()

    def handle_edit_on_list(self, lst):
        owner_id = str(lst[0])
        plot_id = str(lst[1])
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """select F.owner_id, firstname, lastname, plot_id, amount_charged, 
                        plot_name, ST_Area(geom), G.created_at, location_id, phone, address, G.id from 
        	            finale_owner F right join finale_owns G on F.owner_id = G.owner_id right join 
        	            finale_plot p on plot_id = p.plot_number right join 
        	            finale_contact C on C.owner_id = F.owner_id where F.owner_id = '"""+owner_id+"""' and plot_id = '"""+plot_id+"""'"""
            cursor.execute(query)
            row = cursor.fetchall()[0]
            self.editPane.firstname.setText(str(row[1]))
            self.editPane.lastname.setText(str(row[2]))
            self.editPane.balance.setText("e.g 2000")
            self.editPane.phone.setText(str(row[9]))
            self.editPane.address.setText(str(row[10]))
            self.editPane.show()
            query = """
                        select plot_name from 
                        finale_plot P 
                        join finale_owns W on P.plot_number = W.plot_id 
                        join finale_owner O on W.owner_id = O.owner_id 
                        where O.owner_id = '"""+str(owner_id)+"""';
                            """
            self.editPane.personalplot.clear()
            cursor.execute(query)
            for i in cursor:
                self.editPane.personalplot.addItem(i[0])

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('faileed to connect edit details', error)
        finally:
            '''closing database connection'''
            if (connection):
                cursor.close()
                connection.close()
        # self.view_delete_pane_details(owner_id, plot_id)
        # self.viewDeletePane.show()
        self.selectionChangd()
        self.editPane.personalplot.currentIndexChanged.connect(self.selectionChangd)
        self.editPane.payments.currentIndexChanged.connect(lambda : self.deletepayment())
        self.editPane.submit.clicked.connect(lambda x : self.editing(owner_id))

    def editing(self, id):
        firstname = self.editPane.firstname.text()
        lastname = self.editPane.lastname.text()
        phone = self.editPane.phone.text()
        balance = self.editPane.balance.text()
        address = self.editPane.address.toPlainText()

        try:
            connection = self.connection()
            cursor = connection.cursor()

            owns = """select id from finale_owns where owner_id = %s"""
            cursor.execute(owns, (id))
            owns_id = cursor.fetchone()[0]
            feedback = ''
            if self.editPane.editnames.isChecked():
                update_developer = """Update finale_owner set firstname = %s, lastname = %s where owner_id = %s;"""
                cursor.execute(update_developer, (firstname, lastname, str(id)))
                connection.commit()
                feedback = feedback + " Udated Names"

            if self.editPane.editcontacts.isChecked():
                update_contact = """Update finale_contact set phone = %s, address = %s where owner_id = %s;"""
                cursor.execute(update_contact, (phone, address, str(id)))
                connection.commit()
                feedback = feedback + " Updated contacts"

            if self.editPane.oldRadioButton.isChecked():
                payments = self.editPane.payments
                pid = payments.currentData(Qt.UserRole)
                update_payment = """Update finale_payment set amount = %s where id = %s;"""
                cursor.execute(update_payment, (balance, str(pid)))
                connection.commit()
                feedback = feedback + " Udated finances"

            if self.editPane.newRadioButton.isChecked():
                new_payment_on_old_plot = """
                    insert into finale_payment(amount, owns) 
                    values('"""+balance+"""', '"""+str(owns_id)+"""')
                """
                cursor.execute(new_payment_on_old_plot)
                connection.commit()
            
            if self.editPane.delete_pay.isChecked():
                self.deletepayment()

            self.showdialog("Developer updated sucessifully")
            self.editPane.firstname.setText(firstname)
            self.editPane.lastname.setText(lastname)
            self.editPane.phone.setText(phone)
            self.editPane.address.setText(address)
        except(Exception, psycopg2.Error) as error:
            if (connection):
                print("failed at editing", error)
        finally:
            '''closing database connection'''
            if (connection):
                cursor.close()
                connection.close()
        self.available_customers()
        #self.report_customers()
        self.dlg.developerslistwidget.clear()
        self.developers()
        self.editPane.close()

    def delete_ownership(self,owns_id):
        try:
            connection = self.connection()
            cursor = connection.cursor()
            cursor.execute(""" delete from finale_payment where owns = '""" + str(owns_id) + """';""")
            connection.commit()
            cursor.execute(""" delete from finale_owns where id = '""" + str(owns_id) + """'; """)
            connection.commit()
            self.showdialog(" deleted ")
            self.dlg.developerslistwidget.clear()
            self.developers()
            self.viewDeletePane.close()

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed to connect from delete ownership', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def view_delete_pane_details(self, owner_id, plot_id):
        id = ''
        try:
            connection = self.connection()
            cursor = connection.cursor()
            query = """select F.owner_id, firstname, lastname, plot_id, amount_charged, 
                        plot_name, ST_Area(geom), G.created_at, location_id, phone, address, G.id from 
        	            finale_owner F right join finale_owns G on F.owner_id = G.owner_id right join 
        	            finale_plot p on plot_id = p.plot_number right join 
        	            finale_contact C on C.owner_id = F.owner_id where F.owner_id = '"""+str(owner_id)+"""' and plot_id = '"""+str(plot_id)+"""'"""
            cursor.execute(query)
            row = cursor.fetchone()
            id = str(row[11])
            self.viewDeletePane.address.setWordWrap(True)
            self.viewDeletePane.title.setText(str(row[1]) + " " + str(row[2]))
            self.viewDeletePane.address.setText(str(row[10]))
            self.viewDeletePane.phone.setText(str(row[9]))
            self.viewDeletePane.plot.setText(str(row[5]))
            self.viewDeletePane.village.setText("Zomba")
            self.viewDeletePane.charged.setText(str(row[4]))
            # payment
            cursor.execute(""" select fp.id, fp.edited_at, amount from finale_payment fp right join 
                        finale_owns fo on fp.owns = fo.id """)
            data = cursor.fetchall()[0]
            self.viewDeletePane.date_t.setText(str(data[1])[:10])#[20:32])
            self.viewDeletePane.amount.setText(str(data[2]))
            self.viewDeletePane.t_number.setText(str(data[0]))
            self.viewDeletePane.details_delete.clicked.connect(lambda x: self.delete_ownership(id))

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('faileed to from view delete pane',error)
        finally:
            '''closing database connection'''
            if (connection):
                cursor.close()
                connection.close()

    def selectedOwner(self):
        row =  self.dlg.developerslistwidget.currentRow()
        item = self.dlg.developerslistwidget.item(row)

    def rendermap(self, another = None):
        uri = QgsDataSourceUri()
        uri.setConnection("localhost", "5432", "zomba_malawi", "postgres", "12345678")
        uri.setDataSource("public", "finale_plot", "geom")
        vlayer = QgsVectorLayer(uri.uri(), "wholemap", "postgres")
        self.dlg.canvas.setCanvasColor(Qt.white)
        if not vlayer.isValid():
            print("Layer failed to load!")
        QgsProject.instance().addMapLayer(vlayer)
        self.dlg.canvas.setExtent(vlayer.extent())
        self.dlg.canvas.setLayers([another,vlayer])

    def selected_layer(self, number):
        st = "plot_number = "+ number
        uri = QgsDataSourceUri()
        uri.setConnection("localhost", "5432", "zomba_malawi", "postgres", "12345678")
        uri.setDataSource("public", "finale_plot", "geom",st)
        vlayer = QgsVectorLayer(uri.uri(), number, "postgres")
        if not vlayer.isValid():
            print("Layer failed to load!")
        QgsProject.instance().addMapLayer(vlayer)
        self.dlg.map_holder.setExtent(vlayer.extent())
        self.dlg.map_holder.setLayers([vlayer])
        self.rendermap(vlayer)

    def selectionChangd(self):
        pp = self.editPane.personalplot
        txt = pp.currentText()
        try:
            connection = self.connection()
            cursor = connection.cursor()
            details_query = """
                select amount_charged, sum(amount) , S.id 
                from finale_owns S 
                join finale_payment P on S.id = P.owns 
                join finale_plot Po on S.plot_id = Po.plot_number 
                where Po.plot_name = '"""+str(txt)+"""' 
                group by S.amount_charged , S.id
            """
            cursor.execute(details_query)
            row = cursor.fetchone()
            self.editPane.charge.setText(str(row[0]))
            self.editPane.bal.setText(str(row[0]-row[1]))
            owns = row[2]
            payments_q = """
                select amount, id from finale_payment where owns = '"""+str(owns)+"""'
            """
            cursor.execute(payments_q)
            ps = cursor.fetchall()
            self.editPane.payments.clear()
            for i in ps:
                self.editPane.payments.addItem(str(i[0]), QVariant(i[1]))

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed to connect from selection changed', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()

    def deletepayment(self):
        payments = self.editPane.payments
        id = payments.currentData(Qt.UserRole)
        try:
            connection = self.connection()
            cursor = connection.cursor()
            delete_query = """
                delete from finale_payment where id = '"""+str(id)+"""'
            """
            print(id)
            cursor.execute(delete_query)
            connection.commit()

        except(Exception, psycopg2.Error) as error:
            if (connection):
                print('failed to connect from delete payment', error)
        finally:
            '''closing database connection'''
            if (connection):
                     cursor.close()
                     connection.close()